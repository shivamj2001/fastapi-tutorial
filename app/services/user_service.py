from app.db.database import db_pool
from app.schemas.user_request import UserCreate, UserUpdate
from app.schemas.user_response import UserResponse

# users_db = []
# user_id_counter = 1

# def create_user(user: UserCreate) -> UserResponse:
#     global user_id_counter
# 
#     new_user = UserResponse(
#         id=user_id_counter,
#         name=user.name,
#         age=user.age
#     )
# 
#     users_db.append(new_user)
#     user_id_counter += 1
#     return new_user



# --- CREATE USER ---
def create_user(user: UserCreate) -> UserResponse:
    """Inserts a new user into the database and returns the created record."""
    # 1. Borrow a connection from the pool
    conn = db_pool.getconn()
    try:
        # 2. Open a cursor (used to execute SQL commands)
        with conn.cursor() as cur:
            cur.execute(
                """
                INSERT INTO users (name, age)
                VALUES (%s, %s)
                RETURNING id;
                """,
                (user.name, user.age) # 3. Parameterized query to prevent SQL injection
            )
            # 4. Grab the ID generated by the database
            user_id = cur.fetchone()[0]
            # 5. Save the changes permanently
            conn.commit()

            # 6. Return data formatted as the response schema
            return UserResponse(
                id=user_id,
                name=user.name,
                age=user.age
            )
    except Exception:
        # 7. If something crashes, undo any partial changes
        conn.rollback()
        raise
    finally:
        # 8. Crucial: Give the connection back to the pool for others to use
        db_pool.putconn(conn)


# def get_all_users():
#     return users_db





# --- GET ALL USERS ---
def get_all_users():
    """Fetches all user records from the users table."""
    conn = db_pool.getconn()
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT id, name, age FROM users;")
            rows = cur.fetchall() # Retrieve all records as a list of tuples

            # Transform raw database tuples into Pydantic objects
            return [
                UserResponse(id=r[0], name=r[1], age=r[2])
                for r in rows
            ]
    finally:
        db_pool.putconn(conn)






# def get_user_by_id(user_id: int):
#     for user in users_db:
#         if user.id == user_id:
#             return user
#     return None



"""Retrieves a single user by their primary key."""
def get_user_by_id(user_id: int):
    """Retrieves a single user by their primary key."""
    conn = db_pool.getconn()
    try:
        with conn.cursor() as cur:
            cur.execute(
                "SELECT id, name, age FROM users WHERE id = %s;",
                (user_id,)
            )
            row = cur.fetchone()
            # If no user found, return None (useful for 404 logic in routes)
            if not row:
                return None

            return UserResponse(
                id=row[0],
                name=row[1],
                age=row[2]
            )
    finally:
        db_pool.putconn(conn)




# def update_user(user_id: int, updated_data):
#     for user in users_db:
#         if user.id == user_id:
#             if updated_data.name is not None:
#                 user.name = updated_data.name
#             if updated_data.age is not None:
#                 user.age = updated_data.age
#             return user
#     return None





# --- UPDATE USER ---
def update_user(user_id: int, updated_data: UserUpdate):
    """Updates an existing user's data and returns the new state."""
    conn = db_pool.getconn()
    try:
        with conn.cursor() as cur:
            # Note: This query updates ALL fields. 
            # If updated_data has 'None' values, it might overwrite existing data with Null 
            # unless the database handles it or your schema ensures values are present.
            cur.execute(
                """
                UPDATE users
                SET name = %s,
                    age = %s
                WHERE id = %s
                RETURNING id, name, age;
                """,
                (updated_data.name, updated_data.age, user_id)
            )

            row = cur.fetchone()
            if not row:
                return None # No user found with that ID

            conn.commit()
            return UserResponse(id=row[0], name=row[1], age=row[2])
    except Exception:
        conn.rollback()
        raise
    finally:
        db_pool.putconn(conn)



# def delete_user(user_id: int):
#     for user in users_db:
#         if user.id == user_id:
#             users_db.remove(user)
#             return True
#     return False







# --- DELETE USER ---
def delete_user(user_id: int) -> bool:
    """Removes a user from the database. Returns True if successful, False if not found."""
    conn = db_pool.getconn()
    try:
        with conn.cursor() as cur:
            # We use RETURNING id to check if the row actually existed
            cur.execute(
                "DELETE FROM users WHERE id = %s RETURNING id;",
                (user_id,)
            )

            deleted = cur.fetchone()
            if not deleted:
                return False

            conn.commit()
            return True
    except Exception:
        conn.rollback()
        raise
    finally:
        db_pool.putconn(conn)
